	Session.vim	/^map  ggVGY$/;"	m
	Session.vim	/^map!  ggVGY$/;"	m
	Session.vim	/^vmap  "+y$/;"	m
	Session.vim	/^map!  ,$/;"	m
	Session.vim	/^map!  zzi$/;"	m
c	Session.vim	/^nmap c :cs find c =expand("<cword>")$/;"	m
d	Session.vim	/^nmap d :cs find d =expand("<cword>")$/;"	m
e	Session.vim	/^nmap e :cs find e =expand("<cword>")$/;"	m
f	Session.vim	/^nmap f :cs find f =expand("<cfile>")$/;"	m
g	Session.vim	/^nmap g :cs find g =expand("<cword>")$/;"	m
i	Session.vim	/^nmap i :cs find i ^=expand("<cfile>")$/;"	m
s	Session.vim	/^nmap s :cs find s =expand("<cword>")$/;"	m
t	Session.vim	/^nmap t :cs find t =expand("<cword>")$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
0	Session.vim	/^normal! 0$/;"	m
013l	Session.vim	/^normal! 013l$/;"	m
016l	Session.vim	/^normal! 016l$/;"	m
04l	Session.vim	/^normal! 04l$/;"	m
05l	Session.vim	/^normal! 05l$/;"	m
<C-F2>	Session.vim	/^nnoremap <C-F2> :vert diffsplit $/;"	m
<C-F3>	Session.vim	/^map <C-F3> \\be  $/;"	m
<C-F5>	Session.vim	/^map <C-F5> :call CompileRunGcc()$/;"	m
<F12>	Session.vim	/^map <F12> gg=G$/;"	m
<F2>	Session.vim	/^nnoremap <F2> :g\/^\\s*$\/d$/;"	m
<F3>	Session.vim	/^map <F3> :tabnew .$/;"	m
<F5>	Session.vim	/^map <F5> :call Rungdb()$/;"	m
<F6>	Session.vim	/^map <F6> :call CompileC()$/;"	m
<F7>	Session.vim	/^map <F7> :tabp$/;"	m
<F8>	Session.vim	/^map <F8> :tabn$/;"	m
<F9>	Session.vim	/^nmap <silent> <F9> :Tlist$/;"	m
<Nul><Nul>c	Session.vim	/^nmap <Nul><Nul>c :vert scs find c =expand("<cword>")$/;"	m
<Nul><Nul>d	Session.vim	/^nmap <Nul><Nul>d :vert scs find d =expand("<cword>")$/;"	m
<Nul><Nul>e	Session.vim	/^nmap <Nul><Nul>e :vert scs find e =expand("<cword>")$/;"	m
<Nul><Nul>f	Session.vim	/^nmap <Nul><Nul>f :vert scs find f =expand("<cfile>")$/;"	m
<Nul><Nul>g	Session.vim	/^nmap <Nul><Nul>g :vert scs find g =expand("<cword>")$/;"	m
<Nul><Nul>i	Session.vim	/^nmap <Nul><Nul>i :vert scs find i ^=expand("<cfile>")$/;"	m
<Nul><Nul>s	Session.vim	/^nmap <Nul><Nul>s :vert scs find s =expand("<cword>")$/;"	m
<Nul><Nul>t	Session.vim	/^nmap <Nul><Nul>t :vert scs find t =expand("<cword>")$/;"	m
<Nul>c	Session.vim	/^nmap <Nul>c :scs find c =expand("<cword>")$/;"	m
<Nul>d	Session.vim	/^nmap <Nul>d :scs find d =expand("<cword>")$/;"	m
<Nul>e	Session.vim	/^nmap <Nul>e :scs find e =expand("<cword>")$/;"	m
<Nul>f	Session.vim	/^nmap <Nul>f :scs find f =expand("<cfile>")$/;"	m
<Nul>g	Session.vim	/^nmap <Nul>g :scs find g =expand("<cword>")$/;"	m
<Nul>i	Session.vim	/^nmap <Nul>i :scs find i ^=expand("<cfile>")$/;"	m
<Nul>s	Session.vim	/^nmap <Nul>s :scs find s =expand("<cword>")$/;"	m
<Nul>t	Session.vim	/^nmap <Nul>t :scs find t =expand("<cword>")$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)$/;"	m
ADD_SLAVE	common/dbProtocol.h	/^    ADD_SLAVE,   DEL_SLAVE,   $/;"	e	enum:CMD
ADD_SLAVE_R	common/dbProtocol.h	/^    ADD_SLAVE_R, DEL_SLAVE_R, $/;"	e	enum:CMD
APPENDSIZE	common/dbProtocol.h	34;"	d
AddNewSlave	server/slave.c	/^void AddNewSlave(int pos, SlaveNode sn)$/;"	f
AddOpenedDB	server/tcDB.c	/^OpenedDB *AddOpenedDB(char *name, TCHDB *hdb)$/;"	f
AddToSlaveList	server/master.c	/^int AddToSlaveList(SlaveNode sn)$/;"	f
Append	common/dbProtocol.c	/^int Append(char *buf, const char *data, int len)$/;"	f
BACKUP	common/dbProtocol.h	/^    CLIP_DATA,   BACKUP,    FILETRANS,$/;"	e	enum:CMD
BACKUP1_DIR	server/slave.c	24;"	d	file:
BACKUP2_DIR	server/slave.c	25;"	d	file:
BACKUP_POSTFIX	server/slave.c	26;"	d	file:
BACKUP_R	common/dbProtocol.h	/^    CLIP_DATA_R, BACKUP_R,  FILETRANS_R,$/;"	e	enum:CMD
BackupForOtherSlave	server/slave.c	/^void BackupForOtherSlave(int k)$/;"	f
CIRCULAR_QUEUE_H	server/CircularQueue.h	15;"	d
CLIENTOBJ	makefile	/^CLIENTOBJ = $(CLIENTSRC:.c=.o)$/;"	m
CLIENTSRC	makefile	/^CLIENTSRC = $(wildcard .\/client\/*.c .\/common\/*.c)$/;"	m
CLIP_DATA	common/dbProtocol.h	/^    CLIP_DATA,   BACKUP,    FILETRANS,$/;"	e	enum:CMD
CLIP_DATA_R	common/dbProtocol.h	/^    CLIP_DATA_R, BACKUP_R,  FILETRANS_R,$/;"	e	enum:CMD
CLOSE	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
CLOSE_R	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
CMD	common/dbProtocol.h	/^enum CMD {$/;"	g
CMDFAIL	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
CXX	makefile	/^CXX = gcc$/;"	m
CXXFLAGS	makefile	/^CXXFLAGS = -O2 -Wall -g$/;"	m
Check	client/parseinput.c	/^int Check(const char *pat, const char *str)$/;"	f
ClientSockHandle	server/serversocket.h	/^} ClientSockHandle;$/;"	t	typeref:struct:__anon3
ClientSocket	test/testMDB.c	/^} ClientSocket;$/;"	t	typeref:struct:__anon1	file:
ClipDataFromPre	server/slave.c	/^int ClipDataFromPre()$/;"	f
CloseAllCloudNodes	client/netdbapi.c	/^int CloseAllCloudNodes(DataBase hdb, char *buf)$/;"	f
CloseRemoteService	common/Socket.c	/^void CloseRemoteService(int sockfd)$/;"	f
CloudNode	client/netdbapi.c	/^} CloudNode;$/;"	t	typeref:struct:__anon8	file:
DBCreate	client/netdbapi.c	/^DataBase DBCreate(char *dbName)$/;"	f
DBCreate	server/tcDB.c	/^DataBase DBCreate(char *dbName)$/;"	f
DBDelKeyValue	client/netdbapi.c	/^int DBDelKeyValue(DataBase hdb, dbKey key)$/;"	f
DBDelKeyValue	server/tcDB.c	/^int DBDelKeyValue(DataBase db, dbKey key)$/;"	f
DBDelete	client/netdbapi.c	/^int DBDelete(DataBase hdb)$/;"	f
DBDelete	server/tcDB.c	/^int DBDelete(DataBase db)$/;"	f
DBGetKeyValue	client/netdbapi.c	/^dbValue DBGetKeyValue(DataBase hdb, dbKey key)$/;"	f
DBGetKeyValue	server/tcDB.c	/^dbValue DBGetKeyValue(DataBase db, dbKey key)$/;"	f
DBGetLastErrorMsg	server/tcDB.c	/^char *DBGetLastErrorMsg()$/;"	f
DBInitializeService	server/serversocket.c	/^int DBInitializeService(int *psockfd, char *addr, int port)$/;"	f
DBMUTEX	server/tcDB.c	/^pthread_mutex_t DBMUTEX;$/;"	v
DBName	client/dbclient.c	/^char *DBName;$/;"	v
DBPROTOCOL_H	common/dbProtocol.h	15;"	d
DBPacketHeader	common/dbProtocol.h	/^} DBPacketHeader;$/;"	t	typeref:struct:__anon2
DBRecvMsg	server/serversocket.c	/^ClientSockHandle *DBRecvMsg(int sockfd, char *buf)$/;"	f
DBSendMsg	server/serversocket.c	/^void DBSendMsg(ClientSockHandle hcsock, char *buf)$/;"	f
DBServiceStart	server/serversocket.c	/^ClientSockHandle DBServiceStart(int sockfd)$/;"	f
DBServiceStop	server/serversocket.c	/^void DBServiceStop(int sockfd)$/;"	f
DBSetKeyValue	client/netdbapi.c	/^int DBSetKeyValue(DataBase hdb, dbKey key, dbValue value)$/;"	f
DBSetKeyValue	server/tcDB.c	/^int DBSetKeyValue(DataBase db, dbKey key, dbValue value)$/;"	f
DBShutdownService	server/serversocket.c	/^void DBShutdownService(int sockfd)$/;"	f
DEL	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
DEL_R	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
DEL_SLAVE	common/dbProtocol.h	/^    ADD_SLAVE,   DEL_SLAVE,   $/;"	e	enum:CMD
DEL_SLAVE_R	common/dbProtocol.h	/^    ADD_SLAVE_R, DEL_SLAVE_R, $/;"	e	enum:CMD
DataBase	common/Database.h	/^typedef void*          DataBase;$/;"	t
DeQueue	server/CircularQueue.c	/^QueueNode *DeQueue()$/;"	f
Debu	common/dbProtocol.h	100;"	d
DelOpenedDB	server/tcDB.c	/^int DelOpenedDB(OpenedDB *podb)$/;"	f
ECHO	makefile	/^ECHO = @$/;"	m
EnQueue	server/CircularQueue.c	/^void EnQueue(QueueNode *pnode)$/;"	f
ExchangePacket	server/slave.c	/^DBPacketHeader* ExchangePacket(enum CMD cmd, int key, $/;"	f
FAILURE	common/Database.h	26;"	d
FILETRANS	common/dbProtocol.h	/^    CLIP_DATA,   BACKUP,    FILETRANS,$/;"	e	enum:CMD
FILETRANS_R	common/dbProtocol.h	/^    CLIP_DATA_R, BACKUP_R,  FILETRANS_R,$/;"	e	enum:CMD
FILE_MASTER	server/slave.c	28;"	d	file:
FILE_TO_SEND	server/slave.c	27;"	d	file:
FindLongestSection	server/master.c	/^int FindLongestSection()$/;"	f
GET	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
GET_LIST	common/dbProtocol.h	/^    GET_LIST,   GET_LIST_R, $/;"	e	enum:CMD
GET_LIST_R	common/dbProtocol.h	/^    GET_LIST,   GET_LIST_R, $/;"	e	enum:CMD
GET_R	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
GetAppend	common/dbProtocol.c	/^char *GetAppend(DBPacketHeader *phd)$/;"	f
GetFileName	server/slave.c	/^char *GetFileName(int k, char *filename)$/;"	f
GetHeader	common/dbProtocol.c	/^DBPacketHeader *GetHeader(char *buf)$/;"	f
GetLength	server/master.c	/^int GetLength(int pos)$/;"	f
GetMatch	client/parseinput.c	/^int GetMatch(const char *pat, char *str, char *match)$/;"	f
GetOpenedDB	server/tcDB.c	/^OpenedDB *GetOpenedDB(char *name)$/;"	f
GetPort	common/Socket.c	/^int GetPort(int sockfd)$/;"	f
GetSocket	client/netdbapi.c	/^int *GetSocket(DataBase hdb, dbKey key)$/;"	f
HANDLE_REQUESE_H	server/HandleRequest.h	15;"	d
HEARTBEAT	common/dbProtocol.h	/^    HEARTBEAT,    $/;"	e	enum:CMD
HELP	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
HandleCtrlRequest	server/slave.c	/^void HandleCtrlRequest()$/;"	f
HandleMasterRequest	server/slave.c	/^void HandleMasterRequest()$/;"	f
HandleRequest	server/HandleRequest.c	/^void HandleRequest(int id)$/;"	f
HandleRequest	server/master.c	/^void HandleRequest(int sock, int ip)$/;"	f
HandleSlaveRequest	server/slave.c	/^void HandleSlaveRequest()$/;"	f
HelpPrompt	client/parseinput.c	/^void HelpPrompt()$/;"	f
InitQueue	server/CircularQueue.c	/^void InitQueue()$/;"	f
InitThreads	server/HandleRequest.c	/^void InitThreads()$/;"	f
InitializeService	common/Socket.c	/^int InitializeService(int *listen_sock, char *addr, int port)$/;"	f
KillThreads	server/HandleRequest.c	/^void KillThreads()$/;"	f
LOCAL_ADDR	common/Socket.h	18;"	d
MASTEROBJ	makefile	/^MASTEROBJ = .\/common\/dbProtocol.o .\/common\/Socket.o .\/server\/master.o$/;"	m
MAXPACKETLEN	common/dbProtocol.h	33;"	d
MAX_BUF_LEN	common/Socket.h	20;"	d
MAX_CONNECT_QUEUE	common/Socket.h	22;"	d
MAX_FILENAME_LEN	server/slave.c	29;"	d	file:
MAX_INPUT_LEN	client/parseinput.h	19;"	d
MAX_KEY	server/ServerCtrl.h	20;"	d
MAX_QUEUE_LEN	server/CircularQueue.h	19;"	d
MAX_QUEUE_USELEN	server/CircularQueue.h	20;"	d
MAX_SLAVE_NUM	server/ServerCtrl.h	19;"	d
MAX_STRADDR_LEN	common/Socket.h	23;"	d
MDB	server/serversocket.c	/^MemDB MDB;$/;"	v
MDBClose	server/MemoryDB.c	/^void MDBClose(MemDB mdb)$/;"	f
MDBCreate	server/MemoryDB.c	/^MemDB MDBCreate()$/;"	f
MDBDel	server/MemoryDB.c	/^void MDBDel(MemDB mdb, void *kbuf, int ksize)$/;"	f
MDBGet	server/MemoryDB.c	/^void *MDBGet(MemDB mdb, void *kbuf, int ksize, int *sp)$/;"	f
MDBSet	server/MemoryDB.c	/^void MDBSet(MemDB mdb, void *kbuf, int ksize, void *vbuf, int vsize)$/;"	f
MEMORYDB_H	server/MemoryDB.h	15;"	d
MSG_SEM	server/HandleRequest.c	/^sem_t MSG_SEM;$/;"	v
MemDB	server/MemoryDB.h	/^typedef void *MemDB;$/;"	t
NEW_SLAVE	common/dbProtocol.h	/^    NEW_SLAVE,   RM_SLAVE,$/;"	e	enum:CMD
NEW_SLAVE_R	common/dbProtocol.h	/^    NEW_SLAVE_R, RM_SLAVE_R, $/;"	e	enum:CMD
NODES_NUM	client/netdbapi.c	22;"	d	file:
NotifyAll	server/master.c	/^void NotifyAll(int newpos)$/;"	f
OPEN	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
OPEN_R	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
OpenAllCloudNodes	client/netdbapi.c	/^DataBase OpenAllCloudNodes(char *buf)$/;"	f
OpenRemoteService	common/Socket.c	/^int OpenRemoteService(int *psockfd, char *addr, int port)$/;"	f
OpenRemoteService2	common/Socket.c	/^int OpenRemoteService2(int *psockfd, int ip, int port)$/;"	f
OpenedDB	server/tcDB.c	/^} OpenedDB;$/;"	t	typeref:struct:__anon4	file:
PARSEINPUT_H	client/parseinput.h	15;"	d
PORT	common/Socket.h	17;"	d
Parse	client/parseinput.c	/^int Parse(char *input)$/;"	f
Q	server/CircularQueue.c	/^QueueNode Q[MAX_QUEUE_LEN];$/;"	v
QUEUEMUTEX	server/CircularQueue.c	/^pthread_mutex_t QUEUEMUTEX;$/;"	v
QUIT	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
QUIT_R	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
QueueNode	server/CircularQueue.h	/^} QueueNode;$/;"	t	typeref:struct:__anon5
RM_SLAVE	common/dbProtocol.h	/^    NEW_SLAVE,   RM_SLAVE,$/;"	e	enum:CMD
RM_SLAVE_R	common/dbProtocol.h	/^    NEW_SLAVE_R, RM_SLAVE_R, $/;"	e	enum:CMD
RUBBISHFILES	makefile	/^RUBBISHFILES = find . -regex '.*\\.gch\\|.*~\\|.*\\..*hdb' -type f$/;"	m
ReadCloudNodes	client/netdbapi.c	/^int ReadCloudNodes(CloudNode *pnodes)$/;"	f
RecvFile	server/slave.c	/^int RecvFile(int sockfd, char *filename, int len)$/;"	f
RecvMsg	common/Socket.c	/^void RecvMsg(int sockfd, char *buf)$/;"	f
RegMatch	client/parseinput.c	/^int RegMatch(const char *pat, const char *str, int *start, int *end)$/;"	f
RegisterAndLoadSlaves	server/slave.c	/^void RegisterAndLoadSlaves(int master_sock)$/;"	f
ReplaceBackup2ByBackup1	server/slave.c	/^void ReplaceBackup2ByBackup1()$/;"	f
SERVERCTRL_H	server/ServerCtrl.h	15;"	d
SERVEROBJ	makefile	/^SERVEROBJ = $(SERVERSRC:.c=.o)$/;"	m
SERVERSOCKET_H	server/serversocket.h	15;"	d
SERVERSRC	makefile	/^SERVERSRC = $(wildcard .\/server\/*.c .\/common\/*.c)$/;"	m
SET	common/dbProtocol.h	/^    SET,   GET,   DEL,   OPEN,   CLOSE,   QUIT,  HELP,$/;"	e	enum:CMD
SET_R	common/dbProtocol.h	/^    SET_R, GET_R, DEL_R, OPEN_R, CLOSE_R, QUIT_R, CMDFAIL,$/;"	e	enum:CMD
SLAVEOBJ	makefile	/^SLAVEOBJ  = .\/common\/dbProtocol.o .\/common\/Socket.o .\/server\/slave.o$/;"	m
SOCKET_H	common/Socket.h	15;"	d
SUCCESS	common/Database.h	25;"	d
SaveTheSendedFileInBackup1	server/slave.c	/^void SaveTheSendedFileInBackup1()$/;"	f
SendFile	server/slave.c	/^int SendFile(int sockfd, const char *filename)$/;"	f
SendMsg	common/Socket.c	/^void SendMsg(int sockfd, char *buf)$/;"	f
ServiceStart	common/Socket.c	/^int ServiceStart(int listen_sock, int *accept_sock, int *ip)$/;"	f
ServiceStop	common/Socket.c	/^void ServiceStop(int sockfd)$/;"	f
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
SetLastErrorMsg	server/tcDB.c	/^void SetLastErrorMsg(const char *msg)$/;"	f
ShutdownService	common/Socket.c	/^void ShutdownService(int listen_sock)$/;"	f
SlaveList	server/ServerCtrl.h	/^} SlaveList;$/;"	t	typeref:struct:__anon7
SlaveNode	server/ServerCtrl.h	/^} SlaveNode;$/;"	t	typeref:struct:__anon6
TARGET	makefile	/^TARGET = ddbclient ddbserver$/;"	m
TESTGROUP	makefile	/^TESTGROUP = slave master$/;"	m
TESTOBJ	makefile	/^TESTOBJ   = $(TESTSRC:.c=.o) .\/server\/tcDB.o .\/common\/dbProtocol.o .\/server\/MemoryDB.o \\$/;"	m
TESTSRC	makefile	/^TESTSRC   = $(wildcard .\/test\/*.c)$/;"	m
TESTTARGET	makefile	/^TESTTARGET = .\/test\/testtcDB .\/test\/testProtocol .\/test\/testMemory .\/test\/testCircularQueue$/;"	m
THREADS_NUM	server/HandleRequest.c	26;"	d	file:
UPDATE_BACKUP2	common/dbProtocol.h	/^    UPDATE_BACKUP2$/;"	e	enum:CMD
WriteHeader	common/dbProtocol.c	/^void WriteHeader(char *buf, DBPacketHeader *header)$/;"	f
\	Session.vim	/^map <buffer> \\  :w$/;"	m
_DATABASE_H_	common/Database.h	15;"	d
addr	client/netdbapi.c	/^    char addr[MAX_STRADDR_LEN];$/;"	m	struct:__anon8	file:
addr	server/slave.c	/^char *addr;$/;"	v
addr	test/testMDB.c	/^    char addr[50];$/;"	m	struct:__anon1	file:
app	server/serversocket.h	/^    void *app; \/\/ to take sth with socket$/;"	m	struct:__anon3
append	test/testMDB.c	/^    void *append;$/;"	m	struct:__anon1	file:
buf	server/CircularQueue.h	/^    char *buf;$/;"	m	struct:__anon5
cmd	common/dbProtocol.h	/^    enum CMD cmd;$/;"	m	struct:__anon2	typeref:enum:__anon2::CMD
counter	server/tcDB.c	/^    int counter; \/\/ should be lock when multi-thread visite$/;"	m	struct:__anon4	file:
dbKey	common/Database.h	/^typedef unsigned int   dbKey;$/;"	t
dbValue	common/Database.h	/^typedef char*          dbValue;$/;"	t
debug	common/dbProtocol.h	102;"	d
debug	common/dbProtocol.h	107;"	d
debug	server/tcDB.c	23;"	d	file:
fi	Session.vim	/^nmap fi :!firefox %.html & $/;"	m
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
hcsock	server/CircularQueue.h	/^    ClientSockHandle hcsock;$/;"	m	struct:__anon5
hdb	client/parseinput.c	/^DataBase hdb = NULL;$/;"	v
hdb	server/tcDB.c	/^    TCHDB *hdb;$/;"	m	struct:__anon4	file:
head	server/CircularQueue.c	/^int head = 0;$/;"	v
ip	server/ServerCtrl.h	/^    int ip;$/;"	m	struct:__anon6
ip	server/serversocket.h	/^    int ip;$/;"	m	struct:__anon3
isQueueEmpty	server/CircularQueue.c	/^int isQueueEmpty()$/;"	f
isQueueFull	server/CircularQueue.c	/^int isQueueFull()$/;"	f
key	common/dbProtocol.h	/^    int key;$/;"	m	struct:__anon2
key	server/ServerCtrl.h	/^    int key; \/\/ The key that the slave uses.$/;"	m	struct:__anon6
lasterr	server/tcDB.c	/^static char lasterr[1024];$/;"	v	file:
listen_sock	server/slave.c	/^int listen_sock;$/;"	v
main	client/dbclient.c	/^int main()$/;"	f
main	server/dbserver.c	/^int main(int argc, char *argv[])$/;"	f
main	server/master.c	/^int main(int argc, char *argv[])$/;"	f
main	server/slave.c	/^int main(int argc, char *argv[])$/;"	f
main	test/testCircularQueue.c	/^int main()$/;"	f
main	test/testMDB.c	/^int main()$/;"	f
main	test/testProtocol.c	/^int main()$/;"	f
main	test/testtcDB.c	/^int main()$/;"	f
master_sock	server/slave.c	/^int master_sock;$/;"	v
md	Session.vim	/^nmap md :!~\/.vim\/markdown.pl % > %.html $/;"	m
mdb	server/tcDB.c	/^TCMDB *mdb = NULL;  \/\/ The db to save all of the opened db$/;"	v
name	server/tcDB.c	/^    char *name;$/;"	m	struct:__anon4	file:
nodes	server/ServerCtrl.h	/^    SlaveNode nodes[MAX_SLAVE_NUM];$/;"	m	struct:__anon7
num	server/ServerCtrl.h	/^    int num; \/\/ The total number of slaves.$/;"	m	struct:__anon7
pdebug	server/HandleRequest.c	28;"	d	file:
port	client/netdbapi.c	/^    int port;$/;"	m	struct:__anon8	file:
port	server/ServerCtrl.h	/^    int port; \/\/ can not known yet$/;"	m	struct:__anon6
port	server/slave.c	/^int port;$/;"	v
pos	server/slave.c	/^int pos;  \/\/ This server's position in slaves.$/;"	v
printslaves	server/ServerCtrl.h	/^void printslaves(SlaveList sl)$/;"	f
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 152 - ((3 * winheight(0) + 19) \/ 38)$/;"	v
s:l	Session.vim	/^let s:l = 158 - ((10 * winheight(0) + 19) \/ 38)$/;"	v
s:l	Session.vim	/^let s:l = 47 - ((35 * winheight(0) + 19) \/ 38)$/;"	v
s:l	Session.vim	/^let s:l = 51 - ((3 * winheight(0) + 19) \/ 38)$/;"	v
s:l	Session.vim	/^let s:l = 82 - ((3 * winheight(0) + 19) \/ 38)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
size	common/dbProtocol.h	/^    int size;$/;"	m	struct:__anon2
slaves	server/master.c	/^SlaveList slaves;$/;"	v
slaves	server/slave.c	/^SlaveList slaves;$/;"	v
sock	client/netdbapi.c	/^    int sock;$/;"	m	struct:__anon8	file:
sock	server/ServerCtrl.h	/^    int sock;$/;"	m	struct:__anon6
sock	server/serversocket.h	/^    int sock;$/;"	m	struct:__anon3
sock	test/testMDB.c	/^    int sock;$/;"	m	struct:__anon1	file:
tail	server/CircularQueue.c	/^int tail = 0;$/;"	v
thread_id	server/HandleRequest.c	/^pthread_t thread_id[THREADS_NUM];$/;"	v
version	server/ServerCtrl.h	/^    unsigned version;$/;"	m	struct:__anon7
zo	Session.vim	/^normal zo$/;"	m
zt	Session.vim	/^normal! zt$/;"	m
